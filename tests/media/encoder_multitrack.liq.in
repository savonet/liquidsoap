
log.level.set(4)

file = "@FILE@"

a = source.tracks(sine(duration=10.)).audio
a_2 = source.tracks(sine(duration=10.)).audio
v = source.tracks(video.testsrc.ffmpeg(duration=10.)).video
v_2 = source.tracks(video.testsrc.ffmpeg(duration=10.)).video

s = source({audio=a, audio_2=a_2, video=v, video_2=v_2})

s = once(s)

clock.assign_new(sync="none",[s])

done = ref(false)

def on_close(filename) =
  if
    not done()
  then
    done := true

    let json.parse (parsed :
      {
        streams: [
          {
            nb_read_packets: string,
            duration?: string,
            tags?: { DURATION: string }
          }
        ]
      }
    ) = test.ffprobe(count_packets=true, filename)

    def duration(s) =
      if null.defined(s?.duration) then float_of_string(null.get(s?.duration))
      elsif null.defined(s?.tags) then
        matches = r/^([\d]+):([\d]+):(.+)/.exec(null.get(s?.tags).DURATION)
        hours = float_of_string(list.assoc(1, matches))
        minutes = float_of_string(list.assoc(2, matches))
        seconds = float_of_string(list.assoc(3, matches))
        hours*60.*60. + minutes*60. + seconds
      else
        0.
      end
    end

    if
      list.for_all(fun (s) ->
          (duration(s) >= 10.
        or
          int_of_string(s.nb_read_packets) > 0), parsed.streams)
    then
      test.pass()
    else
      test.fail()
    end
  end
end

output.file(
  fallible=true,on_close=on_close,
  @FORMAT@,file,s)
