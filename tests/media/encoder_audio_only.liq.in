
log.level.set(4)

file = "@FILE@"

s = sine(duration=10.)

s = once(s)

clock.assign_new(sync="none",[s])

done = ref(false)

def on_close(filename) =
  if
    not done()
  then
    done := true

    let json.parse (parsed :
      {
        streams: [
          {
            codec_type: string,
            nb_read_packets: string,
            duration?: string,
            tags?: { DURATION: string }
          }
        ]
      }
    ) = test.ffprobe(count_packets=true, filename)

    audio_stream =
      list.find(
        (fun (stream) -> stream.codec_type == "audio"),
        parsed.streams
      )

    def duration(s) =
      if null.defined(s?.duration) then float_of_string(null.get(s?.duration))
      elsif null.defined(s?.tags) then
        matches = r/^([\d]+):([\d]+):(.+)/.exec(null.get(s?.tags).DURATION)
        hours = float_of_string(list.assoc(1, matches))
        minutes = float_of_string(list.assoc(2, matches))
        seconds = float_of_string(list.assoc(3, matches))
        hours*60.*60. + minutes*60. + seconds
      else
        0.
      end
    end

    if
      duration(audio_stream) >= 10.
    or
      int_of_string(audio_stream.nb_read_packets) > 0
    then
      test.pass()
    else
      test.fail()
    end
  end
end

output.file(
  fallible=true,on_close=on_close,
  @FORMAT@,file,s)
